import da
import sys
import random
import os
import copy
import time
import sys

nr_nodes = sys.argv[1]
which_graph = sys.argv[2]
which_run = sys.argv[3]

total_time_results_dir = f'/home/bianca/licenta/distalgo/da/examples/MST/total_time_results/lubys'
node_time_results_dir = f'/home/bianca/licenta/distalgo/da/examples/MST/node_time_results/lubys/{nr_nodes}/graph{which_graph}'

total_time_results_path = total_time_results_dir + f'/{nr_nodes}_total_time_results.txt'
node_time_results_path = node_time_results_dir + f'/run{which_run}_node_time_results.txt'


if not os.path.exists(total_time_results_dir):
    os.makedirs(total_time_results_dir)
    
if not os.path.exists(node_time_results_dir):
    os.makedirs(node_time_results_dir)

total_time_results = open(total_time_results_path, "a")
node_time_results = open(node_time_results_path, "a")
f = open(f"/home/bianca/licenta/distalgo/da/examples/MST/graphs/{nr_nodes}/graph{which_graph}.txt")
config(handling = 'one', channel = 'reliable')
   

class P(process):
    def setup(index: int, neighbors_indexes: tuple, neighbors_process_ids: tuple, neighbors_weights: tuple):
        output("got here")
        neighbors_indexes = list(neighbors_indexes)
        neighbors_process_ids = list(neighbors_process_ids)
        neighbors_weights = list(neighbors_weights)
        
        """
        There are 3 possible states: 
        - Sleeping: initial state
        - Find: while participating in the fragment's search for the minimum-weight outgoing edge
        - Found: rest of the time?
        """
        # SN = state of a node
        self.SN = "Sleeping"
        # FN = fragment node identity
        self.FN = index
        self.index = index
        # LN = level of node
        self.LN = 0
        # best_edge = best outgoing edge for each node
        self.best_edge = None
        # best_wt = best outgoing weight for each node
        self.best_wt = None
        
        self.test_edge = None
        # in_branch = branch to the leader edge of the fragment
        self.in_branch = None
        self.find_count = None
        # number_id : [id, weight, edge state]
        # SE(j) is the state of an edge
        self.branches = {}
        for i in range(len(neighbors_indexes)):
            x = neighbors_indexes[i]
            self.branches[x] = [neighbors_process_ids[i], neighbors_weights[i], "Basic"]
            
        """
        Each node clasifies its adjacent edges into one of 3 possible states:
        - Branch: if the edge is a branch of the current fragment
        - Rejected: if the edge has been discovered to join 2 nodes in the same fragment
        - Basic: otherwise
        """
            
        
        
    def run():
        wakeup()
        
        await()
        
    def wakeup():
        """
        HOW A LEVEL 0 NODE FINDS ITS MWOE
        When a node is woken up, it:
        - first chooses its minimum-weight adjecent edge
        - marks this edge as a Branch of the MST
        - sends a Connect message over this edge
        - goes into the state Found
        - waits for a response from the fragment at the other end of the selected edge
        """
        
        # Chooses its minimum weight adjacent edge
        min_node = None
        min_weight = None
        for (node, (node_id, weight, state)) in self.branches.items():
            if min_weight == None or weight < min_weight:
                min_node = node
                min_weight = weight
             
        # Marks this branch as part of the MST.
        self.branches[min_node][2] = "Branch"   
        self.LN = 0
        self.SN = "Found"
        self.find_count = 0
        
        # Sends a Connect message over this edge.
        send(("Connect", self.LN, self.index), to = self.branches[min_node][0])
        # Waits for a response from the fragment at the other end.
        # !!! aici mai trebuie un await
        # output(f"{self.index} : sent connect")
        
    def receive(msg = ("Connect", L, source_index), from_ = source):
        output(f"{self.index} : received a connect")
        if self.SN == "Sleeping":
            wakeup()
        if L < self.LN:
            """
            INTERACTION BETWEEN LOW LEVEL FRAGMENT F with node n AND HIGH LEVEL FRAGMENT F' with node n'
            There is a strategy in place ot not make low-level fragments wait. 

            So if a node n sends a message to F' and it reaches n', n' immediately sensds an initiate message with identity and level to n.

            If node n' has not yet sent its report message at the given level, fragment F joins the search for the MWOE. In this case you send the 
            node state Find.

            It it has sent its report message, we can deduce that an outgoing edge from node n' has a lower weight thatn the MWOE from F. In this case
            you send the node state Found.

            """
            
            
            # The branch connecting the 2 fragments is part of the MST.
            self.branches[source_index][2] = "Branch"
            
            send(("Initiate", self.LN, self.FN, self.SN, self.index), to = source)
            if self.SN == "Find":
                self.found_count += 1
                
        elif self.branches[source_index][2] == "Basic":
            # If the level is <= it does not respond yet, it waits for its level to become bigger.
            
            # Resends the message to itself.
            send(("Connect", L, source_index), to = self)
        else:
            send(("Initiate", self.LN + 1, self.branches[source_index][1], "Find", self.index), to = source)
        
    def receive(msg = ("Initiate", L, F, S, source_index)):
        # Becoming a higher level.
        self.LN = L
        # Taking the fragment identity.
        self.FN = F
        # Taking the node state indicated.
        self.SN = S 
        # The in branch is the one through which you receive the frament
        self.in_branch = source_index
        self.best_edge = None 
        self.best_wt = 1000000
        
        # Continuing to propagate the new fragment id.
        for branch in list(self.branches.values()):
            send(("Initiate", L, F, S, self.index), to = branch[0])
            if S == "Find":
                self.find_count += 1
        if S == "Find":
            test()
            
    def test():
        self.test_edge = None
        min_weight = None
        # figure out if there are adjacent edges in the state Basic
        basic_adjacent = False
        for branch in list(self.branches.values()):
            if branch[2] == "Basic":
                basic_adjacent = True
                break
        
        
        if basic_adjacent == True:
            
            for branch in list(self.branches.values()):
                # make test_edge = minimum weight outgoing edge in state Basic
                if branch[2] == "Basic":
                    if min_weight == None or min_weight > branch[1]:
                        min_weight = branch[1]
                        self.test_edge = branch[0]
              
            # Send test on test_edge.          
            send(("Test", self.LN, self.FN, self.index), to = self.test_edge)
        else:
            self.test_edge = None
            report()
            
    def receive(msg = ("Test", L, F, source_index)):
        if self.state == "Sleeping":
            wakeup()
        if L > self.LN:
            # !!! place received message at the end of the queue
            send(("Test", L, F, source_index), to = self)
        elif F != self.FN:
            send(("Accept", self.index), to = self.branches[source_index][0])
        else:
            if self.branches[source_index][2] == "Basic":
                self.branches[source_index][2] = "Rejected"
            if self.test_edge != self.branches[source_index][0]:
                send(("Reject", self.index), to = self.branches[source_index][0])
            else:
                test()
                
    def receive(msg = ("Accept", source_index)):
        self.test_edge = None
        if self.branches[source_index][1] < self.best_wt:
            self.best_edge = source_index
            self.best_wt = self.branches[source_index][1]
            report()
            
    def receive(msg = ("Reject", source_index)):
        if self.branches[sourxe_index][2] == "Basic":
            self.branches[sourxe_index][2] = "Rejected"
            test()
            
    def report():
        if self.find_count == 0 and self.test_edge == None:
            self.SN = "Found"
            send(("Report", self.best_wt, self.index), to = self.in_branch)
            
    def receive(msg = ("Report", w, source_index)):
        if source_index != self.in_branch:
            find_count -= 1
            if w > self.best_wt:
                change_root()
            elif w == self.best_wt and w == 100000:
                # !!! halt !!!
    
    def change_root():
        if self.branches[best_edge][2] == "Branch":
            send(("Change root", self.index), to = best_edge)
        else:
            send(("Connect", self.LN, self.index), to = best_edge)
            self.branches[best_edge][2] = "Branch"

    def receive(msg = ("Change root", source_index)):
        change_root()        
        
        
                        

                    
              
        

def main():
    dict = {}
    weights = {}
    line = f.readline()
    # indexing the nodes with 1
    n = 1
    while line:
        line = line.strip("\n")
        list = line.split(' ')
        x = list[0]
        list = list[2:]
        list = [x.split(",") for x in list]
        dict[n] = [int(x[0]) for x in list]
        weights[n] = [int(x[1]) for x in list]
        line = f.readline()
        n += 1
    ps = []
    
    output(dict)
    output(weights)
    
    for i in range(1, n):
        p = new(P, method = 'thread')
        ps.append(p)

    for (i, p) in enumerate(ps):
        ps_ids = []
        for x in dict[i + 1]:
            ps_ids.append(ps[(x - 1)])
        setup({p}, (i + 1, tuple(dict[i + 1]), tuple(ps_ids), tuple(weights[i+1])))
        
    start(ps)