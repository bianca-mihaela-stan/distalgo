import da
import sys
import random
import os
import copy
import time
import sys

nr_nodes = sys.argv[1]
which_graph = sys.argv[2]
which_run = sys.argv[3]

total_time_results_dir = f'/home/bianca/licenta/distalgo/da/examples/MST/total_time_results/lubys'
node_time_results_dir = f'/home/bianca/licenta/distalgo/da/examples/MST/node_time_results/lubys/{nr_nodes}/graph{which_graph}'

total_time_results_path = total_time_results_dir + f'/{nr_nodes}_total_time_results.txt'
node_time_results_path = node_time_results_dir + f'/run{which_run}_node_time_results.txt'


if not os.path.exists(total_time_results_dir):
    os.makedirs(total_time_results_dir)
    
if not os.path.exists(node_time_results_dir):
    os.makedirs(node_time_results_dir)

total_time_results = open(total_time_results_path, "a")
node_time_results = open(node_time_results_path, "a")
f = open(f"/home/bianca/licenta/distalgo/da/examples/MST/graphs/{nr_nodes}/graph{which_graph}.txt")
config(handling = 'one', channel = 'reliable')
   
# INIT = "INIT"
# AWAIT_PULSE = "AWAIT_PULSE"
# AWAIT_ACK_FRAGS_AND_OUT = "AWAIT_ACK_FRAGS_AND_OUT"
# AWAIT_CHOSEN_ROOT = "AWAIT_CHOSEN_ROOT"
# AWAIT_NEW_MESSAGE = "AWAIT_NEW_MESSAGE"
# AWAIT_ECHOS_AND_ACK_MERGES = "AWAIT_ECHOS_AND_ACK_MERGES"
# FINISHED = "FINISHED"
# class State(Enum):
#     global INIT, AWAIT_PULSE, AWAIT_ACK_FRAGS_AND_OUT, AWAIT_CHOSEN_ROOT, AWAIT_NEW_MESSAGE, AWAIT_ECHOS_AND_ACK_MERGES, FINISHED
#     INIT = 1
#     AWAIT_PULSE = 2
#     AWAIT_ACK_FRAGS_AND_OUT = 3
#     AWAIT_CHOSEN_ROOT = 4
#     AWAIT_NEW_MESSAGE = 5
#     AWAIT_ECHOS_AND_ACK_MERGES = 6
#     FINISHED = 7

class P(process):
    def setup(index: int, neighbors_indexes: tuple, neighbors_process_ids: tuple, neighbors_weights: tuple):
        # self.index = index
        # self.neighbors_processes = {neighbors_indexes[i] : neighbors_process_ids[i] for i in range(len(neighbors_indexes))}
        # self.neighbors_weights = {neighbors_indexes[i]: neighbors_weights[i] for i in range(len(neighbors_indexes))}
        # self.leader = index
        # self.level = 0
        # self.terminate = False
        # self.outgoing_edge = None
        
        # output(f"{self.index} : {list(self.neighbors_processes.keys())}")
        
        output("got here")
        neighbors_indexes = list(neighbors_indexes)
        neighbors_process_ids = list(neighbors_process_ids)
        neighbors_weights = list(neighbors_weights)
        
        """
        There are 3 possible states: 
        - Sleeping: initial state
        - Find: while participating in the fragment's search for the minimum-weight outgoing edge
        - Found: rest of the time?
        """
        self.SN = "Sleeping"
        self.branches = {}
        self.ids_to_neigh = {}
        self.FN = index
        self.index = index
        self.LN = 0
        self.best_edge = None
        self.best_wt = None
        self.test_edge = None
        self.in_branch = None
        self.find_count = None
        for i in range(len(neighbors_indexes)):
            x = neighbors_indexes[i]
            self.branches[x] = [neighbors_process_ids[i], neighbors_weights[i], "Basic"]
            
        """
        Each node clasifies its adjacent edges into one of 3 possible states:
        - Branch: if the edge is a branch of the current fragment
        - Rejected: if the edge has been discovered to join 2 nodes in the same fragment
        - Basic: otherwise
        """
            
        
        
    def run():
        wakeup()
        
        await()
        
    def wakeup():
        """
        HOW A LEVEL 0 NODE FINDS ITS MWOE
        When a weight is woken up, it:
        - first chooses its minimum-weight adjecent edge
        - marks this edge as a Branch of the MST
        - sends a Connect message over this edge
        - goes into the state Found
        - waits for a response from the fragment at the other end of the selected edge
        """
        
        
        """
        HOW MERGING WORKS
        For 2 level L-1 fragments that just joined to form a level L fragment over an edge G.
        This edge G becomes the core of the new fragment and the fragment is identified by the id of this edge.
        The 2 nodes adjacent to the core start the new cycle by broadcasting an Initiate message to the other nodes of the fragment.
        This message carries the new fragment level and identity. It also places nodes in the Find state.
        """
        
        """
        HOW A LEVEL > 0 NODE FINDS ITS MWOE
        In order to find the minimum weight outgoing edge a node picks the minimum weight Basic edge and send a Test message on it.
        The test message carries the fragment identity and level.
        
        When a node receives such a test message it checks whether the fragment identities are identical.
        If they are, it sends a Reject message back. Both nodes put the edge into a Rejected state.
        
        The node sending the test message continues by testing the next-best edge.
        
        If the node receiving the test message has a different identity and a >= level, it sends an Accept.
        If the level is <= it does not respond yet, it waits for its level to become bigger.
        
        The reason for this is that when 2 fragments merge, you have to update the identity for all the nodes.
        We restrict this to only update when the level increases.
        """
        
        """
        HOW THE NODES IN A FRAGMENT COOPERATE TO FIND THE OVERALL MWOE
        Each leaf node in the fragment (so a node that has only one Basic edge) sends a message Report(W) on that Basic branch.
        W is the weight of MWOE. If W is infinity, there is no outgoing branch for this node.
        
        Each interior node waits until both:
        - it has found it's own MWOE
        - received messages on all outbound fragment branches (so all Basic branches - 1)
        
        Then, the node chooses the best of these edges to be W and sends this over its inbound edge as Report(W).
        
        When it sends the Report message, it also goes to the state Found. 
        
        Eventually the report messages get to be sent over the core branch and those 2 nodes to determine the MWOE and the side of the edge 
        where this MWOE is.
        """
        
        """
        SENDING THE CHANGE-CORE MESSAGE
        The Change-core message is then sent over the path from the core edge to the MWOE. 
        
        The inbound edge for each node on the path is changed to be the best-edge.
        
        When this message reached the node with the MWOE the inbound edges form a rooted tree in this node.
        
        This node sends the message Connect(L) over the MWOE, where L is the level of the fragment.
        
        """
        
        
        
        
        min_node = None
        min_weight = None
        for (node, (node_id, weight, state)) in self.branches.items():
            if min_weight == None or weight < min_weight:
                min_node = node
                min_weight = weight
             
        self.branches[min_node][2] = "Branch"   
        self.LN = 0
        self.SN = "Found"
        self.find_count = 0
        
        send(("Connect", self.LN, self.index), to = self.branches[min_node][0])
        output(f"{self.index} : sent connect")
        
    def receive(msg = ("Connect", L, source_index), from_ = source):
        output(f"{self.index} : received a connect")
        if self.SN == "Sleeping":
            wakeup()
        if L < self.LN:
            # current branch is self.index -> source_index
            self.branches[source_index][2] = "Branch"
            send(("Initiate", self.LN, self.FN, self.SN), to = source)
            if self.SN == "Find":
                self.found_count += 1
        elif self.branches[source_index][2] == "Basic":
            send(("Connect", L, source_index), to = self)
        else:
            send(("Initiate", self.LN + 1, self.branches[source_index][1], "Find"), to = source)
        
    def receive(msg = ("Initiate", L, F, S, source_index)):
        self.LN = L
        self.FN = F
        self.SN = S 
        self.in_branch = source_index
        self.best_edge = None 
        self.best_wt = 1000000
        
        for branch in list(self.branches.values()):
            send(("Initiate", L, F, S, self.index), to = branch[0])
            if S == "Find":
                self.find_count += 1
        if S == "Find":
            test()
            
    def test():
        self.test_edge = None
        min_weight = None
        basic_adjacent = False
        for branch in list(self.branches.values()):
            if branch[2] == "Basic":
                basic_adjacent = True
                break
        
        if basic_adjacent == True:
            for branch in list(self.branches.values()):
                if min_weight == None or min_weight > branch[1]:
                    min_weight = branch[1]
                    self.test_edge = branch[2]
            send(("Test", self.LN, self.FN), to = self.test_edge)
        else:
            self.test_edge = None
            report()
            
    def report():
        if self.find_count == 0 and self.test_edge == None:
            self.SN = "Found"
            send(("Report", self.best_wt), to = self.in_branch)
            
            
    def receive(msg = ("Test", L, F)):
        
                        

                    
              
        

def main():
    dict = {}
    weights = {}
    line = f.readline()
    # indexing the nodes with 1
    n = 1
    while line:
        line = line.strip("\n")
        list = line.split(' ')
        x = list[0]
        list = list[2:]
        list = [x.split(",") for x in list]
        dict[n] = [int(x[0]) for x in list]
        weights[n] = [int(x[1]) for x in list]
        line = f.readline()
        n += 1
    ps = []
    
    output(dict)
    output(weights)
    
    for i in range(1, n):
        p = new(P, method = 'thread')
        ps.append(p)

    for (i, p) in enumerate(ps):
        ps_ids = []
        for x in dict[i + 1]:
            ps_ids.append(ps[(x - 1)])
        setup({p}, (i + 1, tuple(dict[i + 1]), tuple(ps_ids), tuple(weights[i+1])))
        
    start(ps)